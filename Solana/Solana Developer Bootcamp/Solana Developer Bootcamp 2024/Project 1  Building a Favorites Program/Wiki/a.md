### **Project Setup in Solana Playground**

https://beta.solpg.io/

To begin, create a new **Anchor** project in **Solana Playground**. Give the project a name and clear the contents of the default `lib.rs` file to start from scratch.

-----

### **Core Program Structure**

An **Anchor** program has several key components that define its structure and behavior.

  * **Importing the Prelude**
    The first step is to import the **Anchor** prelude, which provides convenient access to all of its core components.
    `use anchor_lang::prelude::*;`

  * **Declaring the Program ID**
    Every Solana program has a unique address, or `program_id`. This is declared using a macro. **Solana Playground** automatically populates this ID upon deployment.
    `declare_id!("YourProgramIDGoesHere");`

  * **The `#[program]` Macro**
    The `#[program]` macro is the core of **Anchor**. It transforms a standard Rust module into a fully-featured Solana **program**, applying sensible security defaults and handling boilerplate code.

    > ```rust
    > #[program]
    > pub mod favorites {
    >     use super::*;
    >     // Instruction handlers go here
    > }
    > ```

  * **The Anchor Discriminator**
    **Anchor** writes an 8-byte discriminator to the beginning of every account it creates. This discriminator is used to identify the type of the account. It's good practice to define this as a constant.
    `const ANCHOR_DISCRIMINATOR_SIZE: usize = 8;`

-----

### **Defining On-Chain Data with Structs**

Data is stored on the blockchain using Rust `struct`s, enhanced with **Anchor** macros.

  * **Data Struct**
    Define a `struct` that represents the data you want to save. For example, a `Favorites` struct:

    ```rust
    #[account]
    #[derive(InitSpace)]
    pub struct Favorites {
        pub number: u64,
        #[max_len(50)]
        pub color: String,
        #[max_len(5, 50)]
        pub hobbies: Vec<String>,
    }
    ```

  * **Struct Macros**

      * `#[account]`: Marks the struct as a data structure that can be stored in a Solana account.
      * `#[derive(InitSpace)]`: Automatically calculates the byte size needed for the account.
      * `#[max_len(...)]`: For variable-size fields like `String` or `Vec`, you must specify the maximum length to reserve space. For a `Vec<String>`, this is `#[max_len(VECTOR_ITEMS, STRING_LENGTH)]`.

-----

### **Instruction Logic and Accounts**

Instructions are the functions that clients can call to interact with your program. Each instruction requires a specific set of accounts.

  * **Instruction Handler**
    A public function within the `#[program]` module becomes an **instruction handler**. It always takes a `Context` as its first argument, followed by any other data parameters. It returns a `Result<()>`.

    ```rust
    pub fn set_favorites(ctx: Context<SetFavorites>, number: u64, color: String, hobbies: Vec<String>) -> Result<()> {
        // Function logic here
    }
    ```

  * **Accounts Struct**
    For each instruction, you must define an "accounts struct" that specifies all the accounts the instruction will read from or write to. By convention, this struct is named after the instruction in *TitleCase*.

    ```rust
    #[derive(Accounts)]
    pub struct SetFavorites<'info> {
        // Account definitions go here
    }
    ```

  * **Account Constraints**
    Within the accounts struct, you define each required account and its constraints.

      * **User Account (The Signer)**

        ```rust
        #[account(mut)]
        pub user: Signer<'info>,
        ```

          * `mut`: The account is mutable, as the signer will pay for transaction fees and rent.
          * `signer`: This constraint ensures the account owner has signed the transaction.

      * **Favorites Account (The Data Store)**
        This is a **Program Derived Address (PDA)**, a special account whose address is generated by the program itself.

        ```rust
        #[account(
            init_if_needed,
            payer = user,
            space = 8 + Favorites::INIT_SPACE,
            seeds = [b"favorites", user.key().as_ref()],
            bump
        )]
        pub favorites: Account<'info, Favorites>,
        ```

          * `init_if_needed`: Creates the account if it doesn't already exist.
          * `payer = user`: The `user` account will pay for the account's creation.
          * `space`: The total bytes needed for the account (`8` for the discriminator + the data struct's size).
          * `seeds`: An array of bytes used to generate the unique PDA. Here, it's derived from the string "favorites" and the user's public key.
          * `bump`: The nonce used to find a valid PDA address.

      * **System Program**
        The `System Program` is a native Solana program required to create new accounts.
        `pub system_program: Program<'info, System>,`

  * **Handler Implementation Logic**

    1.  **Log Messages:** Use the `msg!` macro to print messages to the transaction logs for debugging.
        `msg!("Greetings from your program!");`
    2.  **Access Accounts:** Access defined accounts through the context: `ctx.accounts.user` or `ctx.accounts.favorites`.
    3.  **Save Data:** Use the `set_inner` method to write data into the favorites account.
        `ctx.accounts.favorites.set_inner(Favorites { number, color, hobbies });`
    4.  **Return Result:** End the function with `Ok(())` to signal successful execution.

-----

### **Build, Deploy, and Test**

  * **Build & Deploy**
    Use the **Build** and **Deploy** buttons in **Solana Playground**. Deploying costs **SOL**, which you can obtain for the Devnet from a faucet like `faucet.solana.com`.

  * **Test**
    Use the **Test** tab to invoke your deployed instruction handlers. You must provide the required arguments and specify the accounts, including the `seeds` for any **PDA**s.

  * **Security with Seeds**

    > **Anchor** automatically enforces the `seeds` constraints. If a user tries to run a transaction using a `favorites` account PDA that was not derived from their own `user` key, the transaction will fail with a `seeds constraint was violated` error. This is a powerful, built-in security feature that prevents users from overwriting each other's data.