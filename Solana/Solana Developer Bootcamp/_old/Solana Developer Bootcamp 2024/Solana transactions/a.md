**Solana Accounts Overview**  

**Types of Accounts**  
- **User Accounts**  
  - Controlled by wallets (e.g., Phantom, Backpack).  
  - Store user assets (e.g., SOL, tokens).  
  - Owned by the **System Program** (`111111111...`).  
- **Data Accounts**  
  - Store data generated by programs (e.g., token balances, NFT metadata).  
  - *Not executable*.  
- **Program Accounts**  
  - Store compiled bytecode of programs (e.g., smart contracts).  
  - *Executable* (marked as `executable: true`).  

---

**Account Structure**  
All accounts contain:  
- **Owner**: Program ID that controls the account (usually a system or user-deployed program).  
- **Executable**: Boolean (`true` for program accounts, `false` otherwise).  
- **Rent Epoch**: Timestamp for rent calculation (set to `u64::MAX` for rent-exempt accounts).  
- **Lamports**: Amount of SOL stored (1 SOL = 1 billion lamports).  
- **Data**: Raw bytes (serialized data or program bytecode).  

---

**Rent & Rent Exemption**  
- Storing data on Solana costs SOL (based on allocated space).  
- **Rent-exempt accounts**: Must hold enough SOL to cover 2 years of storage costs.  
  - *Example*: Use `getMinimumBalanceForRentExemption` (JS/TS) or system program calls (Rust) to calculate required SOL.  
- Non-rent-exempt accounts are deprecated (must be rent-exempt to exist).  

---

**Epoch**  
- A ~2-day period used for:  
  - Stake rewards distribution.  
  - Network upgrades/checkpoints.  
  - Leader scheduling (validator rotation).  

---

**Lifecycle of an Account**  
1. **Creation**: Fund with SOL for rent exemption.  
2. **Data Modification**: Requires signatures from the account’s owner.  
3. **Closure**: Withdraw all lamports to destroy the account.  

---

**Account Creation (Code Example)**  
```typescript  
// Calculate rent exemption  
const space = 0; // Bytes  
const rentExemption = await connection.getMinimumBalanceForRentExemption(space);  

// Generate new keypair  
const newAccount = Keypair.generate();  

// Create transaction  
const transaction = new Transaction().add(  
  SystemProgram.createAccount({  
    fromPubkey: payer.publicKey,  
    newAccountPubkey: newAccount.publicKey,  
    lamports: rentExemption,  
    space: space,  
    programId: SystemProgram.programId,  
  })  
);  

// Send transaction  
await sendAndConfirmTransaction(connection, transaction, [payer, newAccount]);  
```  

---

**Program Derived Addresses (PDAs)**  
- **Definition**: Addresses derived from seeds + program ID (no private key).  
- **Use Cases**:  
  - Store data securely (only the owning program can modify it).  
  - Enable deterministic address generation (e.g., user-specific data storage).  
- **Creation**:  
  ```typescript  
  const [pda, bump] = await PublicKey.findProgramAddress(  
    [Buffer.from("high_score")],  
    programId  
  );  
  ```  

---

**Cross-Program Invocations (CPIs)**  
- Programs interact via PDAs:  
  - *Example*: Token Program uses PDAs for Associated Token Accounts (ATA):  
    - Alice’s ATA: `derive PDA using Alice’s wallet + Token Program ID`.  
    - Bob’s ATA: `derive PDA using Bob’s wallet + Token Program ID`.  
- Enables composability (e.g., swapping tokens via a DEX program calling the Token Program).  

---

**Key Takeaways**  
- **Data Serialization**: All account data is stored as bytes (use libraries like `borsh` for serialization/deserialization).  
- **Ownership**: Programs control accounts via signatures (e.g., PDAs use program authority).  
- **Deterministic Addressing**: PDAs eliminate keypair management for data storage.