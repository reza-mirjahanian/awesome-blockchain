### **Overview of EIP-712**

EIP-712 defines a standard for hashing and signing typed structured data in Ethereum, extending signable messages beyond transactions and raw bytestrings to include structured data (denoted as 𝕊). It ensures machine-verifiable and human-readable signing, preventing errors in hashing that could compromise security. The standard is compliant with EIP-191 and requires EIP-155 for chain ID handling.

Key components:
- **Typed Data Encoding**: Structures are encoded into bytestrings for hashing and signing.
- **Domain Separation**: Uses a domain separator to prevent cross-domain signature reuse.
- **Hashing Algorithm**: Safe hashing of structs, including recursive and array types.
- **RPC Call**: Introduces `eth_signTypedData` for signing.

### **Atomic and Encodable Types**

EIP-712 types mirror Solidity types but are EVM-agnostic. Types are divided into atomic (basic) and complex (structs, arrays).

**Atomic Types Table**:

| Type       | Description                          | Encoding Rule                                                                 |
|------------|--------------------------------------|-------------------------------------------------------------------------------|
| `bytes1` to `bytes32` | Fixed-size byte arrays (1-32 bytes) | Directly as 32-byte left-padded value.                                        |
| `bytes`    | Dynamic byte array                   | `keccak256` hash of the bytes.                                                |
| `string`   | Dynamic string                       | `keccak256` hash of the UTF-8 encoded string.                                 |
| `uint8` to `uint256` | Unsigned integers (8-256 bits)     | As 32-byte big-endian value.                                                  |
| `int8` to `int256` | Signed integers (8-256 bits)        | As 32-byte big-endian two's complement value.                                 |
| `bool`     | Boolean                              | As `uint256`: 1 for true, 0 for false.                                        |
| `address`  | Ethereum address                     | As `uint160` (20-byte address in 32-byte field).                              |

**Complex Types**:
- **Structs**: Named collections of members (e.g., `struct Mail { address from; address to; string contents; }`).
- **Arrays**: Fixed-size (`Type[n]`) or dynamic (`Type[]`), where `Type` can be atomic or complex.
- **Custom Types**: Valid identifiers (alphanumeric + underscore, no leading underscore or digit).

Rules:
- Types must be acyclic (no recursive self-references in dependency graph).
- Encoding is deterministic and injective.

### **Encoding and Hashing Functions**

**encodeType(type)**: Produces a string representation for hashing.
- For atomic types: Just the type name (e.g., `uint256`).
- For arrays: `encodeType(elementType) + "[" + size + "]"` if fixed, or `encodeType(elementType) + "[]"` if dynamic.
- For structs: `StructName(MemberType1 memberName1,MemberType2 memberName2,...)`, sorted by member declaration order.

**Code Snippet (Solidity - Computing Type Hash)**:
```solidity
function typeHash() internal pure returns (bytes32) {
    return keccak256("Mail(address from,address to,string contents)");
}
```

**encodeData(structInstance)**: Encodes struct values into bytes.
- Concatenate: `typeHash` + encoded members in order.
- Atomic: As per table.
- Dynamic bytes/string: `keccak256(value)`.
- Arrays: `keccak256(encodeData of all elements concatenated)`.
- Nested structs: Recursively `encodeData`.

**hashStruct(structInstance)**: `keccak256(encodeData(structInstance))`.

**domainSeparator**: `keccak256(encodeData(EIP712Domain))`, where `EIP712Domain` is a struct with optional fields:
- `name`: string (human-readable app name).
- `version`: string (app version).
- `chainId`: uint256 (EIP-155 chain ID).
- `verifyingContract`: address (contract verifying the signature).
- `salt`: bytes32 (extra entropy).

**Full Message Hash**: `keccak256("\x19\x01" || domainSeparator || hashStruct(message))`.

**Code Snippet (JavaScript - Using ethers.js for Encoding)**:
```javascript
const { ethers } = require("ethers");

const domain = {
    name: "MyApp",
    version: "1",
    chainId: 1,
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
};

const types = {
    Mail: [
        { name: "from", type: "address" },
        { name: "to", type: "address" },
        { name: "contents", type: "string" }
    ]
};

const message = {
    from: "0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    to: "0xBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    contents: "Hello, Ethereum!"
};

const domainSeparator = ethers.TypedDataEncoder.hashDomain(domain);
const hashStruct = ethers.TypedDataEncoder.hashStruct("Mail", types.Mail, message);
const fullHash = ethers.TypedDataEncoder.encode(domain, types, message); // Or manual: keccak256("\x19\x01" + domainSeparator + hashStruct)
console.log(fullHash);
```

### **Signing and Verification**

**Signing**: Use `eth_signTypedData` RPC (or variants like `eth_signTypedData_v3`, `eth_signTypedData_v4` for backwards compat).
- Input: JSON with `domain`, `types`, `primaryType` (root struct name), `message`.
- Output: ECDSA signature (v, r, s).

**Code Snippet (Signing with ethers.js)**:
```javascript
async function signTypedData(signer, domain, types, message) {
    return await signer.signTypedData(domain, types, message);
}
```

**Verification (On-Chain)**: Recover signer via `ecrecover(fullHash, v, r, s)` and compare to expected address.

**Code Snippet (Solidity - Verification)**:
```solidity
function recoverSigner(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
    return ecrecover(messageHash, v, r, s);
}

function verify(bytes32 domainSeparator, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
    bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, hashStruct));
    return recoverSigner(digest, v, r, s);
}
```

### **Use Cases and Edge Cases with Code Snippets**

**Basic Struct Signing**:
- Use: Off-chain approvals.
```javascript
// As above Mail example.
```

**Nested Structs**:
- Edge: Deep nesting requires correct type dependency resolution.
```solidity
struct Person { string name; uint age; }
struct Mail { Person from; Person to; string contents; }
// typeHash: keccak256("Mail(Person from,Person to,string contents)Person(string name,uint256 age)")
```

**Arrays**:
- Fixed: `uint[3] fixedArray;`
- Dynamic: `uint[] dynamicArray;`
- Encoding: keccak256 of concatenated encoded elements.
- Edge: Empty array hashes to keccak256(0x).
```javascript
const types = { ArrayStruct: [{ name: "nums", type: "uint256[]" }] };
const message = { nums: [1, 2, 3] };
```

**Bytes/String Hashing**:
- Edge: Long strings (>32 bytes) are hashed, not padded.
- Trick: Always UTF-8 for strings to avoid encoding mismatches.

**Domain with Salt**:
- Use: For extra security in multi-app setups.
```json
{ "name": "App", "version": "1", "chainId": 1, "verifyingContract": "0x...", "salt": "0xabcdef..." }
```

**Edge: Missing Domain Fields**:
- Only include used fields; unused are omitted from encodeData.
- Trick: If no domain, risk cross-chain replay; always include chainId.

**Edge: Acyclic Check**:
- Invalid: `struct A { A self; }` (cycle).
- Tip: Build dependency graph and check for cycles before implementation.

**Edge: Type Name Collisions**:
- Types must be unique; no overloading.

### **Comparisons with Similar Concepts**

- **vs eth_sign (Personal Sign)**: EIP-712 uses structured types for readability; eth_sign is raw bytes prefixed with "\x19Ethereum Signed Message:\n". EIP-712 adds domain separation, preventing malleability.
- **vs signMessage in Wallets**: Similar to eth_sign but wallet-specific; lacks typing.
- **vs EIP-191**: EIP-712 builds on it, using version 0x01 with domain + struct hash.
- **vs ABI Encoding**: ABI is for function calls (dynamic padding); EIP-712 is hashing-focused (fixed 32-byte for atoms).

**Pros/Cons Table**:

| Aspect          | Pros                                                                 | Cons                                                              |
|-----------------|----------------------------------------------------------------------|-------------------------------------------------------------------|
| Security       | Domain separation prevents replay/cross-app attacks; typed to avoid hashing errors. | Requires careful domain config; no built-in nonce/replay protection. |
| Usability      | Human-readable in wallets (e.g., MetaMask shows fields).             | More complex JSON input than raw hex.                             |
| Performance    | Efficient EVM implementation; off-chain signing saves gas.           | On-chain verification slightly more gas (extra keccak256).        |
| Compatibility  | Backwards with EIP-191; widely supported (ethers.js, web3.js).      | Older wallets may not support _v4 variant.                        |

### **Tricky Parts and Explanations**

- **Type Hashing Order**: Members must be in declaration order, not alphabetical. Trick: Always verify with `encodeType` string.
- **Recursive Encoding**: For nested structs, resolve types bottom-up. Edge: Large nests can cause stack overflow in naive recursion; use iterative encoding.
- **Domain Extensibility**: Add custom fields to EIP712Domain, but they must be defined in types. Trick: Omit unused fields to save bytes.
- **Chain ID Handling**: Must match EIP-155; mismatch leads to invalid recovery. Tip: Query chainId dynamically in dApps.
- **Signature Malleability**: EIP-712 hash prevents it, but ensure v is 27/28 (not 0/1).
- **Wallet Variations**: MetaMask uses _v4 for arrays/nests; Ledger may require _v3. Trick: Detect wallet and fallback.
- **UTF-8 Pitfalls**: Strings with emojis/special chars; always encode as UTF-8 before hashing.
- **Zero Values**: Handled naturally (e.g., address(0) is valid).

### **Real-World Usage and Projects**

- **OpenSea/Seaport**: Uses EIP-712 for signed orders in NFT marketplaces; allows gasless listings.
  - Example: Signing bid/ask orders with domain {name: "Seaport", version: "1.1", chainId, verifyingContract}.
- **Uniswap Permits (EIP-2612)**: Extends ERC-20 with permit function using EIP-712 for signed approvals.
  - Code: `permit(owner, spender, value, deadline, v, r, s)` verifies EIP-712 sig off-chain.
- **Gnosis Safe**: Multisig wallets use it for batched tx approvals.
- **ENS**: Domain registrations via signed messages.
- **Decentraland**: Avatar/land interactions.
- **Projects**: ethers.js (built-in support), viem (TypeScript lib), OpenZeppelin (SafeCast for types).

**Implementation Stats Table** (Based on Adoption as of 2025):

| Project/Library | Support Level | Key Feature |
|-----------------|---------------|-------------|
| MetaMask        | Full (_v4)   | UI display of fields. |
| ethers.js       | Full         | TypedDataEncoder class. |
| web3.js         | Partial      | Manual hashing needed. |
| Hardhat         | Full         | Testing utils for sigs. |
| Foundry         | Full         | Forge std lib for EIP-712. |

### **Next Steps**

EIP-1271: Standard for verifying signatures on Ethereum contracts.