EIP-712 provides a standard for hashing and signing typed structured data instead of just byte strings. The primary goal is to improve user experience and security by displaying readable, domain-specific data in wallets during signing prompts, mitigating phishing risks associated with opaque `eth_sign` messages.

-----

## Core Concepts

EIP-712 solves the problem of "blind signing." Before EIP-712, users were often asked to sign a cryptic hex string (`0x...`), with no way of knowing what data they were actually approving. This was a major security risk.

EIP-712 introduces a new signing method, `eth_signTypedData_v4`, which takes a JSON object containing the data to be signed. This allows wallets like MetaMask to display the data in a human-readable format.

The signature is constructed from two main parts:

1.  **Domain Separator (`domainSeparator`):** A unique identifier for the specific application or domain. It prevents a signature created for one dapp from being valid in another.
2.  **Struct Hash (`hashStruct`):** A hash of the application-specific message data, structured according to predefined types.

The final message to be signed is:
`\x19\x01` + `domainSeparator` + `hashStruct(message)`

  - `\x19\x01`: The version byte prefix. `\x19` is intended to prevent signed messages from being valid Ethereum transactions, and `\x01` is the version specific to EIP-712.

-----

## How It Works: Hashing & Structure

### The `EIP712Domain` Struct

This struct defines the scope of the signature, preventing replay attacks across different chains or contracts.

| Field               | Type      | Description                                                                 |
| ------------------- | --------- | --------------------------------------------------------------------------- |
| `name`              | `string`  | The user-friendly name of the signing domain (e.g., "My Awesome DApp").      |
| `version`           | `string`  | The current version of the signing domain (e.g., "1", "2.0").               |
| `chainId`           | `uint256` | The chain ID of the network (e.g., 1 for Ethereum Mainnet).                 |
| `verifyingContract` | `address` | The address of the contract that will verify the signature.                 |
| `salt`              | `bytes32` | An arbitrary value to prevent collisions between otherwise identical domains. |

### Application-Specific Struct

This is the data you want the user to sign. You define the structure with named and typed fields. The standard supports elementary types (`address`, `uint256`, `bytes32`, etc.), dynamic types (`bytes`, `string`), and nested structs.

### Solidity Implementation

In your smart contract, you must compute the same hash that the user's wallet computes.

**1. Defining Structs and Hashes**

First, define the `typeHash` for your domain and your message. A `typeHash` is the `keccak256` of the struct's definition string.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// EIP712 is inherited to get access to hashing utilities.
contract MyEIP712Contract is EIP712 {
    // Keccak256 hash of the name of the contract's EIP712 domain.
    // EIP712("My Awesome DApp", "1")
    // Note: OpenZeppelin's EIP712 constructor handles creating the domainSeparator.
    
    // Type hash for our custom message struct.
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c8;
    
    // Nonce for each user to prevent signature replay.
    mapping(address => uint256) public nonces;

    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }

    constructor(string memory name, string memory version) EIP712(name, version) {}

    function getMessageHash(Permit memory permit) public view returns (bytes32) {
        return _hashTypedDataV4(keccak256(abi.encode(
            PERMIT_TYPEHASH,
            permit.owner,
            permit.spender,
            permit.value,
            permit.nonce,
            permit.deadline
        )));
    }

    function verify(Permit memory permit, bytes memory signature) public view returns (address) {
        bytes32 messageHash = getMessageHash(permit);
        return ECDSA.recover(messageHash, signature);
    }
}
```

### JavaScript Client-Side Signing (ethers.js v6)

On the client side, you construct the domain and message objects and use the wallet's `signer` to produce the signature.

```javascript
import { ethers } from 'ethers';

// Assume 'signer' is an ethers.js Signer instance (e.g., from a browser provider)
// and 'contractAddress' is the address of the deployed contract.

async function signPermit(signer, contractAddress, chainId) {
    const ownerAddress = await signer.getAddress();
    
    const domain = {
        name: 'My Awesome DApp',
        version: '1',
        chainId: chainId,
        verifyingContract: contractAddress
    };

    const types = {
        Permit: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' }
        ]
    };

    const message = {
        owner: ownerAddress,
        spender: '0x...', // The address being approved
        value: ethers.parseEther('100'),
        nonce: 0, // Should be fetched from the contract's `nonces(ownerAddress)`
        deadline: Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
    };

    try {
        const signature = await signer.signTypedData(domain, types, message);
        console.log('Signature:', signature);
        return signature;
    } catch (error) {
        console.error('Signing failed:', error);
    }
}
```

-----

## Comparison of Signing Methods

| Feature              | `eth_sign` (Deprecated)                               | `personal_sign`                                         | `EIP-712` (`eth_signTypedData_v4`)                               |
| -------------------- | ----------------------------------------------------- | ------------------------------------------------------- | ---------------------------------------------------------------- |
| **Data Format** | Arbitrary hex string.                                 | Arbitrary string.                                       | Structured JSON object.                                          |
| **User Experience** | ðŸš¨ **Very Poor.** Shows a cryptic, unreadable hash.   | ðŸ¤” **Poor.** Shows the full string, but lacks structure.  | âœ… **Excellent.** Shows a clean, formatted table of data.         |
| **Security** | ðŸš¨ **Dangerous.** A signed hash could match a real tx. | ðŸ‘ **Good.** Prefixed to prevent being a valid transaction. | âœ… **Excellent.** Domain-separated and structured, minimizing risk. |
| **Use Case** | Legacy systems. **Avoid using.** | Simple off-chain messages, login signatures.            | Meta-tx, off-chain orders, gasless approvals, DAO votes.          |
| **Wallet Prompt** | "Sign this hash: 0x..."                               | "Sign this message: Welcome to My DApp\!"                | "Approve Transfer of 100 DAI to 0x..."                           |

-----

## Pros & Cons

| Pros                                                                                                | Cons                                                                                              |
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| âœ… **Enhanced Security:** Users know exactly what they are signing, preventing phishing attacks.      | ðŸ¥µ **Implementation Complexity:** Requires careful setup on both the smart contract and client-side. |
| âœ… **Great User Experience:** Wallets display data in a human-readable format.                       | ðŸ› **Prone to Errors:** A mismatch in type definitions or encoding between client and contract leads to invalid signatures. |
| âœ… **Gasless Operations:** Enables meta-transactions where a relayer can submit a user's signed intent. | â›“ï¸ **Chain-Specific:** Signatures are tied to a `chainId`, which is a feature but requires re-signing for other chains. |
| âœ… **On-Chain Efficiency:** Instead of storing entire messages, only the signature needs verification. | ðŸ“¦ **Larger Payload:** The signature object is larger than a simple hash.                         |

-----

## Tricky Parts & Explanations

### Domain Separator Replay Protection

The `domainSeparator` is your primary defense against replay attacks.

  * **`chainId`**: Prevents a signature for a contract on a testnet (e.g., Sepolia) from being re-used on Mainnet.
  * **`verifyingContract`**: Prevents a signature intended for `ContractA` from being used on `ContractB`, even if they have identical functions.
  * **`salt`**: Can be used to differentiate between deployment environments (e.g., staging vs. production) if they share the same contract address and chainId (e.g., on a forked devnet).

### Hashing and Encoding Rules

The devil is in the details of how different types are encoded before being hashed.

  * **`bytes` and `string`**: The *hash* of the dynamic content is used, not the content itself. `keccak256(bytes)` or `keccak256(utf8(string))`.
  * **Structs**: The `typeHash` of the struct definition is concatenated with the encoded values of its members.
  * **Arrays**: The hash of the concatenated encoded elements is used.
  * **Padding**: All elementary types (`uint256`, `address`, `bytesN`) are padded to 32 bytes.

An error in any of these steps on either the client or the contract will result in a signature mismatch. **Using a well-tested library like OpenZeppelin's EIP712 implementation is highly recommended.**

-----

## Real-World Usage

  * **ERC-20 `permit` Function:** As seen in `USDC` and `DAI`, this allows a user to sign an `approval` message off-chain. A third party (like a DeFi protocol) can then use that signature to call `permit` and subsequently `transferFrom` in a single transaction, saving the user from needing to make a separate `approve` transaction first. â›½ï¸

    ```solidity
    // Example from a simplified ERC20Permit contract
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, "PERMIT_EXPIRED");
        bytes32 messageHash = // ... construct EIP-712 hash
        address signer = ecrecover(messageHash, v, r, s);
        require(signer == owner && signer != address(0), "INVALID_SIGNATURE");
        _approve(owner, spender, value);
    }
    ```

  * **NFT Marketplace Orders (OpenSea, LooksRare):** When you "list" an NFT for sale, you are not submitting a transaction. You are signing an EIP-712 message containing the order details (NFT contract, token ID, price, expiration). OpenSea stores this signature. When a buyer accepts the offer, they submit your signed order to the marketplace contract, which verifies your signature and executes the atomic swap (NFT for ETH/WETH).

  * **Meta-Transactions:** For dapps that want to onboard users without crypto, a user can sign a message describing the action they want to take. A "relayer" service pays the gas fee to submit this signed message to a trusted forwarder contract, which verifies the signature and executes the intended call on behalf of the user.

-----

## Next Steps

### EIP-1271: Signature Validation for Smart Contracts

EIP-712 defines how an Externally Owned Account (EOA) can sign data. But what if the "signer" is a smart contract wallet, like a Gnosis Safe or Argent wallet? These wallets don't have a private key; they are controlled by code.

**EIP-1271** solves this by specifying a standard interface for contracts to implement a function that declares whether a given signature is valid for them.

```solidity
// ERC1271.sol
interface IERC1271 {
    /**
     * @dev Should return the magic value 0x1626ba7e if the signature is valid for the given data.
     * Should return other values if the signature is invalid.
     */
    function isValidSignature(
        bytes32 hash,
        bytes calldata signature
    ) external view returns (bytes4 magicValue);
}
```

Dapps that rely on signatures (like those using EIP-712) should check if the signer is a contract. If so, they should call `isValidSignature` on that contract address to verify the signature, rather than using `ecrecover`. This makes your application compatible with the growing ecosystem of smart contract wallets.