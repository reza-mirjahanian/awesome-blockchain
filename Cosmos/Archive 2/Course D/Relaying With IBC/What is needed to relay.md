Before moving on to look at specific implementations of relayer software, understand the general set of requirements or functionality that relayer software needs to have.

1.  **Information about the chains:** a relayer will relay packets between a pair of chains, so it requires some information about these chains.
2.  **Information about the path:** once you know the chains you are relaying on, the next requirement is to know which path to relay on. Remember, the IBC protocol has **three main layers** of abstraction: the (light) clients, connections, and channels (and ports).
3.  **A private key:** to a relayer operator address on all chains that you want to relay on. Remember that a relayer needs to submit IBC messages to the chains they are relaying between (Receive, Acknowledge, and Timeout), which typically require a fee. Therefore the relayer operator address needs to have funds.
4.  **Ability to query and submit messages (or transactions):** as mentioned already, chains do not communicate directly with one another. It is the relayer's job to listen for events related to a packet commitment. They can do this by subscribing to these events via the CometBFT WebSocket, and querying the proofs via the CometBFT RPC endpoint. You also can query and create through transactions clients, connections, and channels. There are transactions to update and upgrade light clients, submit a notice of misbehavior, and those that allow you to relay packets and acknowledgements or timeouts. For more detail, you will look at the command lists for the Go and Hermes relayers next.

![](https://ida.interchain.io/hi-tip-icon.svg)

With the current architecture, relayers use the CometBFT RPC endpoint to query for the commitment proof, as the proofs that are required to submit IBC messages to the counterparty chain (more specifically the light client) for verification are not available via gRPC. Relayer calls can put significant pressure on the RPC endpoints of the nodes, which is one of the main bottlenecks currently in production. Because the CometBFT RPC is single-threaded, large amounts of relayer calls may cause the node to run out of sync, requiring regular resets.