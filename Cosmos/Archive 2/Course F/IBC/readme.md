**IBC is to the internet of blockchains, what TCP/IP is to the internet**.

In the same way that a *TCP/IP* packet is unaware of whether it carries *HTTPS/FTP* or any other protocol data, IBC is application-agnostic and you can transfer all types of data using it. IBC enables the transport layer between two chains in a way that maintains data authenticity and packet ordering. This is why the base layer of IBC is known as TAO -- transport, authentication and ordering. On top of that, we can have different modules that use IBC as their communication layer; those are referred to as IBC Applications.

For an active connection between *chain A* and *chain B,* we must have the following:

-   *Chain A* will run a **light client** of *chain B* and vice versa. A [light client](https://ethereum.org/en/developers/docs/nodes-and-clients/light-clients/#what-is-a-light-client) maintains only the necessary information to verify transactions on the blockchain. This is done so that each chain can validate commitments from its counterparty without having to trust any third party in the middle or store the entire blockchain.
-   **IBC software**. This is comprised of three layers:
    -   IBC Core layer for transport, authentication and ordering of packets. This is consistent across all chains.
    -   Specific IBC applications that operate on top of IBC. This is similar to *HTTP* running on *TCP/IP*. An example is [ICS-20](https://github.com/cosmos/ibc/blob/main/spec/app/ics-020-fungible-token-transfer/README.md), used for fungible token transfers across different chains.
    -   Application Modules. These are the Cosmos-SDK modules we mentioned in the previous section. They can talk to the IBC application and use its data.
-   **Relayers**. While the light clients in the connection are the base of trust between the two chains, they can only **authenticate** packet commitment on the counterparty chain. This essentially means that *chain A* can commit to some packet data by writing the packet hash to *chain A*'s ledger so that *chain B* can ensure this commitment has passed the consensus phase on *chain A*. The relayer is the code responsible for transferring the packet data (not only the hash). The relayer shouldn't be trusted by any chain. It's simply there to transfer the information from one chain to another, and each chain is responsible for authenticating this data using the commitment (i.e., the packet hash) in the other chain. It's an elegant solution so that we don't have to write all of the data in IBC packets to the blockchain itself for the sake of scalability. Figure 4 illustrates how relayers integrate into IBC. You can find more information on relayers can be found in [ICS-18](https://github.com/cosmos/ibc/tree/main/spec/relayer/ics-018-relayer-algorithms).


A connection between two chains is usually set up once and will probably not be terminated while the two chains are operating. The connection itself is the abstraction layer for the IBC protocol. On top of a connection, channels can be opened and a unique channel ID identifies a channel. On top of those channels, application modules open a port, which they use to communicate to an application in the counterparty chain. Every packet that goes through IBC has a source channel and port in the sending chain, as well as a destination channel and port in the receiving chain.

Channel management and packet handling are implemented using callback functions that the IBC core invokes. Different modules can register callback functions to implement various functionalities, and these functions are called one after the other.